%\pdfpageattr {/Group << /S /Transparency /I true /CS /DeviceRGB>>}
\documentclass[10pt, xcolor={usenames, dvipsnames}]{beamer}

\usepackage[french, english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{upgreek,textgreek}
\usepackage{animate}

\usepackage{fnpct}

\usepackage{pifont}
\newcommand{\cmark}{\ding{51}}
\newcommand{\xmark}{\ding{55}}

\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{graphicx}
\usepackage{hyperref}
\usepackage[style=alphabetic, autocite=inline, firstinits=true, maxnames=2]{biblatex}
\bibliography{bibliographie}
%\renewcommand*{\bibfont}{\small}

\usepackage{makecell}
\usepackage{tabularx, booktabs}
\usepackage{tikz}
\definecolor{light-gray}{gray}{0.65}
\tikzset{fade on/.code={\only<#1>{\color{light-gray}}}}
\tikzset{hide on/.code={\only<#1>{\color{white}}}}
\tikzset{bold on/.code={\only<#1>{\bfseries}}}
\tikzset{
  opinvisible/.style={opacity=0.2},
  visible on/.style={alt={#1{}{opinvisible}}},
  alt/.code args={<#1>#2#3}{%
    \alt<#1>{\pgfkeysalso{#2}}{\pgfkeysalso{#3}} % \pgfkeysalso doesn't change the path
  },
}

\usetikzlibrary{plotmarks,shapes}
\usepackage{colortbl}
\usepackage{ulem}
\usepackage{multicol}
\usepackage[overlay]{textpos}
\usepackage{multirow}
\usepackage{ragged2e}
\usepackage{rotating}
\usepackage{fancybox}
\usepackage{ulem}
\usepackage{overpic}
\usepackage{enumerate}
\usepackage{xfrac}
\usepackage{pgfplots}

\usepackage{transparent}

\usepackage{epstopdf}
\usepackage{epsfig}


\newcommand{\REF}{\textcolor{purple}{REF}}
\newcommand{\GO}[1]{\textcolor{blue}{#1}}
\newcommand{\YES}[1]{\textcolor{green}{#1}}
\newcommand{\NO}[1]{\textcolor{red}{#1}}

\usetheme{metropolis}

\title{Breaking the Scalability Barrier of Causal Broadcast for Large and Dynamic Systems}
\author{Brice N\'edelec, Pascal Molli, and \textbf{Achour Most{\'e}faoui}}
\date{Workshop O'Browser 2018}
\institute{University of Nantes, LS2N}



\begin{document}

\maketitle

\begin{frame}{Introduction}

  Causal broadcast is the core of many distributed applications such as
  distributed social networks, distributed collaborative softwares, or
  distributed data stores.

  \vspace{3em}
  
    \begin{minipage}{0.19\textwidth}
      \centering
      \includegraphics[width=0.7\textwidth]{logos/facebook.png}
    \end{minipage}
    \begin{minipage}{0.19\textwidth}
      \centering
      \includegraphics[width=0.7\textwidth]{logos/mastodon.png}
    \end{minipage}
    \begin{minipage}{0.19\textwidth}
      \centering
      \includegraphics[width=0.7\textwidth]{logos/telegram.png}
    \end{minipage}    
    \begin{minipage}{0.19\textwidth}
      \centering
      \includegraphics[width=0.7\textwidth]{logos/google.png}
    \end{minipage}
    \begin{minipage}{0.19\textwidth}
      \centering
      \includegraphics[width=0.8\textwidth]{logos/riak.png}
    \end{minipage}

\end{frame}


\begin{frame}{Causal broadcast}

  Causal broadcast is a reliable broadcast that ensures a specific ordering
  among message deliveries. 
  
  \begin{definition}[Lamport's Happen before]
    Happen before is a transitive, irreflexive, and antisymmetric relation
    $\rightarrow$ that defines a strict partial orders of events.  The sending
    of a message always precedes its receipt.
  \end{definition}

  \vspace{2em}

  \begin{definition}[Causal order]
    The delivery order of messages follows the happen before relationships of the
    corresponding broadcasts. $\forall A,\,B,\,C,\,
    b_A(m) \rightarrow b_B(m') \implies d_C(m) \rightarrow d_C(m')$
  \end{definition}

  \textit{When Alice comments Bob's picture, everyone sees Alice's comment after
    Bob's picture.}  

\end{frame}


\begin{frame}{Static systems: \YES{\cmark}}
  
  \vspace{2em}
  
  Simply broadcast and forward each message exactly once using all outgoing FIFO
  links and you have causal broadcast\footnote{Friedman et al. Causal ordering
    in deterministic overlay networks.}.

  \begin{minipage}{0.32\textwidth}
    \begin{center}
      % \subfloat[Part A][\label{fig:generalsolveA}Process~A broadcasts $a$.]
      \input{input/figgeneralsolveA.tex}
    \end{center}
  \end{minipage}
  \begin{minipage}{0.32\textwidth}
    \begin{center}
      % \subfloat[Part B][\label{fig:generalsolveB}Process~B receives and 
      % delivers $a$. Process~B forwards $a$ using its FIFO links.]
      \input{input/figgeneralsolveB.tex}
    \end{center}
  \end{minipage}
  \begin{minipage}{0.32\textwidth}
    \begin{center}
      % \subfloat[Part C][\label{fig:generalsolveC}Process~B broadcasts $b$.]
      \input{input/figgeneralsolveC.tex}
    \end{center}
  \end{minipage}
  
  \begin{center}
  \begin{minipage}{0.35\textwidth}
    \begin{center}
    % \subfloat[Part D][\label{fig:generalsolveD}Process~A receives and 
    % delivers $b$. Process~A forwards $b$ using its FIFO links.]
      \input{input/figgeneralsolveD.tex}
    \end{center}
  \end{minipage}
  \begin{minipage}{0.35\textwidth}
    \begin{center}
    % \hspace{40pt}
    % \subfloat[Part E][\label{fig:generalsolveE}Process~C cannot receive $b$
    % without having received $a$ beforehand.]
      \input{input/figgeneralsolveE.tex}
    % \caption{\label{fig:generalsolve}Causal broadcast~\cite{friedman2004causal}
    %   ensures causal order.}
    \end{center}
  \end{minipage}
  \end{center}

  Propagation ensures causal order by design. It is very efficient, for message
  overhead remains constant $O(1)$.

  \vspace{2em}

\end{frame}

\begin{frame}{Large scale static systems: \YES{\cmark}}

  Each process has a partial view much smaller than the actual system size and
  efficiently propagates messages using gossiping.

  \begin{center}
    \input{input/figdisseminationtree.tex}
  \end{center}

  Gossiping is already mandatory for large scale systems. It is not an
  additional overhead of causal broadcast.

\end{frame}



\begin{frame}{But dynamic systems: \NO{\xmark}}

  New links may act as shortcut for new messages impairing causal order.

  \begin{minipage}{0.32\textwidth}
    \vspace{1pt}
    \begin{center}
      % \subfloat[Part A][\label{fig:generalsolveA}Process~A broadcasts $a$.]
      \input{input/figpreventiveproblemA.tex}
    \end{center}
  \end{minipage}
  \begin{minipage}{0.32\textwidth}
    \vspace{1pt}
    \begin{center}
      % \subfloat[Part B][\label{fig:generalsolveB}Process~B receives and 
      % delivers $a$. Process~B forwards $a$ using its FIFO links.]
      \input{input/figpreventiveproblemA2.tex}
    \end{center}
  \end{minipage}
  \begin{minipage}{0.32\textwidth}
    \begin{center}
      % \subfloat[Part C][\label{fig:generalsolveC}Process~B broadcasts $b$.]
      \input{input/figpreventiveproblemB.tex}
    \end{center}
  \end{minipage}
  
  \begin{center}
  \begin{minipage}{0.35\textwidth}
    \begin{center}
    % \subfloat[Part D][\label{fig:generalsolveD}Process~A receives and 
    % delivers $b$. Process~A forwards $b$ using its FIFO links.]
      \input{input/figpreventiveproblemC.tex}
    \end{center}
  \end{minipage}
  \begin{minipage}{0.35\textwidth}
    \begin{center}
    % \hspace{40pt}
    % \subfloat[Part E][\label{fig:generalsolveE}Process~C cannot receive $b$
    % without having received $a$ beforehand.]
      \input{input/figpreventiveproblemD.tex}
    % \caption{\label{fig:generalsolve}Causal broadcast~\cite{friedman2004causal}
    %   ensures causal order.}
    \end{center}
  \end{minipage}
  \end{center}  

  Not only Process~D fails to deliver messages in causal order but propagates the
  mistake to the rest of processes.

\end{frame}


\begin{frame}{Positioning}
  
  \begin{center}
  \begin{table}
    \begin{center}
      \caption{\label{table:comparison} Complexity of causal
        broadcast protocols.
        $N$ is the number of processes that ever broadcast a message.
        $W$ is the number of received messages awaiting delivery.
        $P$ is the number of delivered messages that are temporarily kept before
        being safely purged to forbid double delivery.%
        % $B$ is the number of delivered messages that are temporarily kept to
        % check the safety of new communication means.
      }
      \input{input/tableoverlayvstimestamp.tex}
    \end{center}
  \end{table}
  \end{center}

\end{frame}


\begin{frame}[standout]
  How do we keep the complexity of causal broadcast for large scale static
  systems in dynamic settings where processes can join, leave, or
  self-reconfigure at any time?
\end{frame}

\begin{frame}{Proposal: PC-broadcast}  

  PC-broadcast stands for Preventive Causal broadcast. It prevents causal order
  violations by forbidding the usage of new links until proven safe. Each
  process uses all and only safe links for causal broadcast.
  
\end{frame}

\begin{frame}{Safe links}

  \begin{definition}[\label{def:safe}Safe link]
    A link from Process~A to Process~B is safe if and only if Process~B received
    or will receive all messages delivered by Process~A before receiving any
    message that Process~A will deliver:
    $safe_{AB} \equiv \forall m,\, m',\, d_A(m) \rightarrow s_{AB}(m') \implies
    r_B(m) \rightarrow r_{BA}(m')$
  \end{definition}

  \vspace{2em}

  Links start unsafe. The challenge is to make links safe using local knowledge
  only. Sending all delivered messages since the beginning makes safe links but
  is over-expansive: \NO{\xmark}. We will use few lightweight control messages
  that follow causal order: \YES{\cmark}.

\end{frame}


\begin{frame}{Control messages and buffering make safe links}
  
  \begin{enumerate}
  \item Sending a control message using safe link to the other process
    $\rightarrow$ will acknowledge the delivery of most of past messages
  \item Buffer all delivered messages $\rightarrow$ saves concurrent messages to
    safe link establishment
  \item Upon acknowledgment of the control message, send the buffer of
    concurrent messages
  \end{enumerate}


  \begin{minipage}{0.32\textwidth}
    \vspace{4pt}
    \begin{center}
      % \subfloat[Part A][\label{fig:generalsolveA}Process~A broadcasts $a$.]
      \input{input/figpreventivesolveA.tex}
    \end{center}
  \end{minipage}
  \begin{minipage}{0.32\textwidth}
    \begin{center}
      % \subfloat[Part B][\label{fig:generalsolveB}Process~B receives and 
      % delivers $a$. Process~B forwards $a$ using its FIFO links.]
      \input{input/figpreventivesolveB.tex}
    \end{center}
  \end{minipage}
  \begin{minipage}{0.32\textwidth}
    \begin{center}
      % \subfloat[Part C][\label{fig:generalsolveC}Process~B broadcasts $b$.]
      \input{input/figpreventivesolveC.tex}
    \end{center}
  \end{minipage}
  
  \begin{center}
  \begin{minipage}{0.35\textwidth}
    \begin{center}
    % \subfloat[Part D][\label{fig:generalsolveD}Process~A receives and 
    % delivers $b$. Process~A forwards $b$ using its FIFO links.]
      \input{input/figpreventivesolveD.tex}
    \end{center}
  \end{minipage}
  \begin{minipage}{0.35\textwidth}
    \begin{center}
    \vspace{9pt}
    % \hspace{40pt}
    % \subfloat[Part E][\label{fig:generalsolveE}Process~C cannot receive $b$
    % without having received $a$ beforehand.]
      \input{input/figpreventivesolveE.tex}
    % \caption{\label{fig:generalsolve}Causal broadcast~\cite{friedman2004causal}
    %   ensures causal order.}
    \end{center}
  \end{minipage}
  \end{center}    

\end{frame}


\begin{frame}{The size of buffers may increase without bound}

  System conditions such as high latency, crashes, or unreliable communications
  may lead to unbounded growth of buffers.

  \begin{minipage}{0.98\textwidth}
    \begin{center}
      % \subfloat[Part A][\label{fig:generalsolveA}Process~A broadcasts $a$.]
      \input{input/figbufferproblemA.tex}
    \end{center}
  \end{minipage}
  \begin{minipage}{0.98\textwidth}
    \begin{center}
      % \subfloat[Part B][\label{fig:generalsolveB}Process~B receives and 
      % delivers $a$. Process~B forwards $a$ using its FIFO links.]
      \input{input/figbufferproblemB.tex}
    \end{center}
  \end{minipage}
  \begin{minipage}{0.98\textwidth}
    \begin{center}
      % \subfloat[Part C][\label{fig:generalsolveC}Process~B broadcasts $b$.]
      \input{input/figbufferproblemC.tex}
    \end{center}
  \end{minipage}

  
\end{frame}

\begin{frame}{Handling failures}

  \begin{enumerate}
  \item Above a buffer size threshold, retry.
  \item Too many attempts, abort.
  \end{enumerate}

  \begin{minipage}{0.32\textwidth}
    \vspace{16pt}
    \begin{center}
      % \subfloat[Part A][\label{fig:generalsolveA}Process~A broadcasts $a$.]
      \input{input/figbuffersolveA.tex}
    \end{center}
  \end{minipage}
  \begin{minipage}{0.32\textwidth}
    \vspace{12pt}
    \begin{center}
      % \subfloat[Part B][\label{fig:generalsolveB}Process~B receives and 
      % delivers $a$. Process~B forwards $a$ using its FIFO links.]
      \input{input/figbuffersolveB.tex}
    \end{center}
  \end{minipage}
  \begin{minipage}{0.32\textwidth}
    \begin{center}
      % \subfloat[Part C][\label{fig:generalsolveC}Process~B broadcasts $b$.]
      \input{input/figbuffersolveC.tex}
    \end{center}
  \end{minipage}
  
  \begin{center}
  \begin{minipage}{0.35\textwidth}
    \begin{center}
    % \subfloat[Part D][\label{fig:generalsolveD}Process~A receives and 
    % delivers $b$. Process~A forwards $b$ using its FIFO links.]
      \input{input/figbuffersolveD.tex}
    \end{center}
  \end{minipage}
  \begin{minipage}{0.35\textwidth}
  \vspace{20pt}
    \begin{center}
    % \hspace{40pt}
    % \subfloat[Part E][\label{fig:generalsolveE}Process~C cannot receive $b$
    % without having received $a$ beforehand.]
      \input{input/figbuffersolveE.tex}
    % \caption{\label{fig:generalsolve}Causal broadcast~\cite{friedman2004causal}
    %   ensures causal order.}
    \end{center}
  \end{minipage}
  \end{center}    

\end{frame}

\begin{frame}{Experimentation: small negative impact on the overlay}

  \small The overlay network is built using a random peer-sampling protocol. Processes
  periodically exchange outgoing links. Links are bidirectional. Each new safe
  link costs 3 control messages.

  \vspace{-5pt}

  \begin{center}
    \includegraphics[width=0.7\textwidth]{img/delay.eps}
  \end{center}
  
  \vspace{-5pt}

  \small Messages arrive slightly later, for PC-broadcast temporarily forbids the use
  of new links. This is overlay-specific: removing an arc from a random-graph is
  not very impactful.

\end{frame}

\begin{frame}{Conclusion}
  
  PC-broadcast constitutes a simple and efficient implementation for causal broadcast
  in large and dynamic systems.

  Depending on the overlay network, the cost in terms of number of control
  messages and its negative impact on overlay's properties remains low.

  \vspace{2em}

  \begin{center}
  \begin{table}
    \begin{center}
      \input{input/tablelineourapproach.tex}
    \end{center}
  \end{table}
  \end{center}


\end{frame}

\begin{frame}[standout]
  To be continued\ldots Removing the last monotonic upper bound on space complexity.
\end{frame}

\begin{frame}[standout]
  To be continued 2\ldots Retrieving partial order out of flattened orders.
\end{frame}


\end{document}
